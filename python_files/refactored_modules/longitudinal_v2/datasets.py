from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Iterable, List, Sequence, Tuple

import nibabel as nib
import numpy as np
import torch
from torch.utils.data import Dataset


def _load_nifti_2d(path: str) -> np.ndarray:
    arr = nib.load(path).get_fdata()
    if arr.ndim != 2:
        raise ValueError(f"Expected 2D nifti at {path}, got shape {arr.shape}")
    return arr.astype(np.float32)


def _is_sample_dir(d: str) -> bool:
    req = [
        "prior.nii.gz",
        "intermediate.nii.gz",
        "current.nii.gz",
    ]
    return all(os.path.isfile(os.path.join(d, r)) for r in req)


def _find_sample_dirs(roots: Sequence[str]) -> List[str]:
    sample_dirs: List[str] = []
    for root in roots:
        if not root:
            continue
        if os.path.isdir(root) and _is_sample_dir(root):
            sample_dirs.append(root)
            continue
        for cur, dirs, files in os.walk(root):
            if _is_sample_dir(cur):
                sample_dirs.append(cur)
    sample_dirs.sort()
    return sample_dirs


@dataclass(frozen=True)
class TripletItem:
    prior: torch.Tensor
    intermediate: torch.Tensor
    current: torch.Tensor
    diff_entity: torch.Tensor
    diff_full: torch.Tensor
    mask: torch.Tensor


class TripletDRRDataset(Dataset):
    """Dataset for DRR triplets generated by `CT_entities/DRR_generator_triplet.py`.

    Expects each sample directory to contain:
      - prior.nii.gz
      - intermediate.nii.gz
      - current.nii.gz
    Optionally:
      - diff_map.nii.gz  (prior->current)

    Returns tensors as [1,H,W] per item (DataLoader will batch to [B,1,H,W]).
    """

    def __init__(self, roots: Sequence[str]):
        self.sample_dirs = _find_sample_dirs(list(roots))
        if not self.sample_dirs:
            raise ValueError(
                "TripletDRRDataset found 0 samples. Provide roots containing folders with prior/intermediate/current.nii.gz"
            )

    def __len__(self) -> int:
        return len(self.sample_dirs)

    def __getitem__(self, idx: int) -> TripletItem:
        d = self.sample_dirs[idx]
        prior = _load_nifti_2d(os.path.join(d, "prior.nii.gz"))
        intermediate = _load_nifti_2d(os.path.join(d, "intermediate.nii.gz"))
        current = _load_nifti_2d(os.path.join(d, "current.nii.gz"))

        # Targets
        diff_entity = current - intermediate
        diff_map_p = os.path.join(d, "diff_map.nii.gz")
        if os.path.isfile(diff_map_p):
            diff_full = _load_nifti_2d(diff_map_p)
        else:
            diff_full = current - prior

        # Default mask: all valid pixels
        mask = np.ones_like(prior, dtype=np.float32)

        def to_t(x: np.ndarray) -> torch.Tensor:
            return torch.from_numpy(x).unsqueeze(0)  # [1,H,W]

        return TripletItem(
            prior=to_t(prior),
            intermediate=to_t(intermediate),
            current=to_t(current),
            diff_entity=to_t(diff_entity),
            diff_full=to_t(diff_full),
            mask=to_t(mask),
        )


class DRRImageDataset(Dataset):
    """Image-only DRR dataset for encoder pretraining.

    This is meant for Stage E (reconstruction): the encoder should not collapse/ignore
    content such as devices. We therefore train it with an auxiliary reconstruction
    objective on large collections of DRRs.

    Supported layouts (mixed is OK):
    - Single-variation DRRs: root/case/var123.nii.gz
    - Pair folders: root/case/pair/{prior,current}.nii.gz
    - Triplet folders: root/case/pair/{prior,intermediate,current}.nii.gz

    Skips diff maps (diff_map/difference_map) by filename.
    Returns: image tensor [1,H,W] (DataLoader -> [B,1,H,W]).
    """

    _skip_names = {
        "diff_map.nii.gz",
        "difference_map.nii.gz",
        "diff_entity.nii.gz",
    }

    def __init__(self, roots: Sequence[str]):
        self.paths: List[str] = []
        for root in roots:
            if not root:
                continue
            for cur, _, files in os.walk(root):
                for fn in files:
                    if not fn.endswith(".nii.gz"):
                        continue
                    if fn in self._skip_names:
                        continue
                    # common DRR names
                    if fn in {"prior.nii.gz", "current.nii.gz", "intermediate.nii.gz"}:
                        self.paths.append(os.path.join(cur, fn))
                        continue
                    # single-variation naming
                    if fn.startswith("var") and fn.endswith(".nii.gz"):
                        self.paths.append(os.path.join(cur, fn))

        self.paths.sort()
        if not self.paths:
            raise ValueError(
                "DRRImageDataset found 0 images. Provide roots containing var*.nii.gz or prior/current/intermediate.nii.gz"
            )

    def __len__(self) -> int:
        return len(self.paths)

    def __getitem__(self, idx: int) -> torch.Tensor:
        arr = _load_nifti_2d(self.paths[idx])
        return torch.from_numpy(arr).unsqueeze(0)  # [1,H,W]
